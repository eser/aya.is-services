// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stories.sql

package storage

import (
	"context"
	"database/sql"
)

const getStoryById = `-- name: GetStoryById :one
SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
WHERE s.id = $2
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryByIdParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Id         string `db:"id" json:"id"`
}

type GetStoryByIdRow struct {
	Story   Story   `db:"story" json:"story"`
	StoryTx StoryTx `db:"story_tx" json:"story_tx"`
}

// GetStoryById
//
//	SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	WHERE s.id = $2
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryById(ctx context.Context, arg GetStoryByIdParams) (*GetStoryByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryById, arg.LocaleCode, arg.Id)
	var i GetStoryByIdRow
	err := row.Scan(
		&i.Story.Id,
		&i.Story.AuthorProfileId,
		&i.Story.Slug,
		&i.Story.Kind,
		&i.Story.Status,
		&i.Story.IsFeatured,
		&i.Story.StoryPictureUri,
		&i.Story.Title,
		&i.Story.Summary,
		&i.Story.Content,
		&i.Story.Properties,
		&i.Story.PublishedAt,
		&i.Story.CreatedAt,
		&i.Story.UpdatedAt,
		&i.Story.DeletedAt,
		&i.StoryTx.StoryId,
		&i.StoryTx.LocaleCode,
		&i.StoryTx.Title,
		&i.StoryTx.Summary,
		&i.StoryTx.Content,
	)
	return &i, err
}

const getStoryBySlug = `-- name: GetStoryBySlug :one
SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
WHERE s.slug = $2
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryBySlugParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Slug       string `db:"slug" json:"slug"`
}

type GetStoryBySlugRow struct {
	Story   Story   `db:"story" json:"story"`
	StoryTx StoryTx `db:"story_tx" json:"story_tx"`
}

// GetStoryBySlug
//
//	SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	WHERE s.slug = $2
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryBySlug(ctx context.Context, arg GetStoryBySlugParams) (*GetStoryBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryBySlug, arg.LocaleCode, arg.Slug)
	var i GetStoryBySlugRow
	err := row.Scan(
		&i.Story.Id,
		&i.Story.AuthorProfileId,
		&i.Story.Slug,
		&i.Story.Kind,
		&i.Story.Status,
		&i.Story.IsFeatured,
		&i.Story.StoryPictureUri,
		&i.Story.Title,
		&i.Story.Summary,
		&i.Story.Content,
		&i.Story.Properties,
		&i.Story.PublishedAt,
		&i.Story.CreatedAt,
		&i.Story.UpdatedAt,
		&i.Story.DeletedAt,
		&i.StoryTx.StoryId,
		&i.StoryTx.LocaleCode,
		&i.StoryTx.Title,
		&i.StoryTx.Summary,
		&i.StoryTx.Content,
	)
	return &i, err
}

const getStoryIdBySlug = `-- name: GetStoryIdBySlug :one
SELECT id
FROM "story"
WHERE slug = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetStoryIdBySlugParams struct {
	Slug string `db:"slug" json:"slug"`
}

// GetStoryIdBySlug
//
//	SELECT id
//	FROM "story"
//	WHERE slug = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryIdBySlug(ctx context.Context, arg GetStoryIdBySlugParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoryIdBySlug, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const listStories = `-- name: ListStories :many
SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
WHERE s.deleted_at IS NULL
`

type ListStoriesParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
}

type ListStoriesRow struct {
	Story   Story   `db:"story" json:"story"`
	StoryTx StoryTx `db:"story_tx" json:"story_tx"`
}

// ListStories
//
//	SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	WHERE s.deleted_at IS NULL
func (q *Queries) ListStories(ctx context.Context, arg ListStoriesParams) ([]*ListStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listStories, arg.LocaleCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoriesRow{}
	for rows.Next() {
		var i ListStoriesRow
		if err := rows.Scan(
			&i.Story.Id,
			&i.Story.AuthorProfileId,
			&i.Story.Slug,
			&i.Story.Kind,
			&i.Story.Status,
			&i.Story.IsFeatured,
			&i.Story.StoryPictureUri,
			&i.Story.Title,
			&i.Story.Summary,
			&i.Story.Content,
			&i.Story.Properties,
			&i.Story.PublishedAt,
			&i.Story.CreatedAt,
			&i.Story.UpdatedAt,
			&i.Story.DeletedAt,
			&i.StoryTx.StoryId,
			&i.StoryTx.LocaleCode,
			&i.StoryTx.Title,
			&i.StoryTx.Summary,
			&i.StoryTx.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesByAuthorProfileId = `-- name: ListStoriesByAuthorProfileId :many
SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
WHERE s.author_profile_id = $2
  AND s.deleted_at IS NULL
`

type ListStoriesByAuthorProfileIdParams struct {
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	AuthorProfileId sql.NullString `db:"author_profile_id" json:"author_profile_id"`
}

type ListStoriesByAuthorProfileIdRow struct {
	Story   Story   `db:"story" json:"story"`
	StoryTx StoryTx `db:"story_tx" json:"story_tx"`
}

// ListStoriesByAuthorProfileId
//
//	SELECT s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.title, s.summary, s.content, s.properties, s.published_at, s.created_at, s.updated_at, s.deleted_at, st.story_id, st.locale_code, st.title, st.summary, st.content
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	WHERE s.author_profile_id = $2
//	  AND s.deleted_at IS NULL
func (q *Queries) ListStoriesByAuthorProfileId(ctx context.Context, arg ListStoriesByAuthorProfileIdParams) ([]*ListStoriesByAuthorProfileIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoriesByAuthorProfileId, arg.LocaleCode, arg.AuthorProfileId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoriesByAuthorProfileIdRow{}
	for rows.Next() {
		var i ListStoriesByAuthorProfileIdRow
		if err := rows.Scan(
			&i.Story.Id,
			&i.Story.AuthorProfileId,
			&i.Story.Slug,
			&i.Story.Kind,
			&i.Story.Status,
			&i.Story.IsFeatured,
			&i.Story.StoryPictureUri,
			&i.Story.Title,
			&i.Story.Summary,
			&i.Story.Content,
			&i.Story.Properties,
			&i.Story.PublishedAt,
			&i.Story.CreatedAt,
			&i.Story.UpdatedAt,
			&i.Story.DeletedAt,
			&i.StoryTx.StoryId,
			&i.StoryTx.LocaleCode,
			&i.StoryTx.Title,
			&i.StoryTx.Summary,
			&i.StoryTx.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
