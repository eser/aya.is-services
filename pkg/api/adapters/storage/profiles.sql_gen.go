// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: profiles.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const createProfile = `-- name: CreateProfile :one
INSERT INTO "profile" (id, slug)
VALUES ($1, $2) RETURNING id, slug, kind, custom_domain, profile_picture_uri, pronouns, properties, created_at, updated_at, deleted_at
`

type CreateProfileParams struct {
	Id   string `db:"id" json:"id"`
	Slug string `db:"slug" json:"slug"`
}

// CreateProfile
//
//	INSERT INTO "profile" (id, slug)
//	VALUES ($1, $2) RETURNING id, slug, kind, custom_domain, profile_picture_uri, pronouns, properties, created_at, updated_at, deleted_at
func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (*Profile, error) {
	row := q.db.QueryRowContext(ctx, createProfile, arg.Id, arg.Slug)
	var i Profile
	err := row.Scan(
		&i.Id,
		&i.Slug,
		&i.Kind,
		&i.CustomDomain,
		&i.ProfilePictureUri,
		&i.Pronouns,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getProfileById = `-- name: GetProfileById :one
SELECT p.id, p.slug, p.kind, p.custom_domain, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties
FROM "profile" p
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = $1
WHERE p.id = $2
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetProfileByIdParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Id         string `db:"id" json:"id"`
}

type GetProfileByIdRow struct {
	Profile   Profile   `db:"profile" json:"profile"`
	ProfileTx ProfileTx `db:"profile_tx" json:"profile_tx"`
}

// GetProfileById
//
//	SELECT p.id, p.slug, p.kind, p.custom_domain, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties
//	FROM "profile" p
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = $1
//	WHERE p.id = $2
//	  AND p.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileById(ctx context.Context, arg GetProfileByIdParams) (*GetProfileByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileById, arg.LocaleCode, arg.Id)
	var i GetProfileByIdRow
	err := row.Scan(
		&i.Profile.Id,
		&i.Profile.Slug,
		&i.Profile.Kind,
		&i.Profile.CustomDomain,
		&i.Profile.ProfilePictureUri,
		&i.Profile.Pronouns,
		&i.Profile.Properties,
		&i.Profile.CreatedAt,
		&i.Profile.UpdatedAt,
		&i.Profile.DeletedAt,
		&i.ProfileTx.ProfileId,
		&i.ProfileTx.LocaleCode,
		&i.ProfileTx.Title,
		&i.ProfileTx.Description,
		&i.ProfileTx.Properties,
	)
	return &i, err
}

const getProfileIdByCustomDomain = `-- name: GetProfileIdByCustomDomain :one
SELECT id
FROM "profile"
WHERE custom_domain = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetProfileIdByCustomDomainParams struct {
	CustomDomain sql.NullString `db:"custom_domain" json:"custom_domain"`
}

// GetProfileIdByCustomDomain
//
//	SELECT id
//	FROM "profile"
//	WHERE custom_domain = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileIdByCustomDomain(ctx context.Context, arg GetProfileIdByCustomDomainParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getProfileIdByCustomDomain, arg.CustomDomain)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getProfileIdBySlug = `-- name: GetProfileIdBySlug :one
SELECT id
FROM "profile"
WHERE slug = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetProfileIdBySlugParams struct {
	Slug string `db:"slug" json:"slug"`
}

// GetProfileIdBySlug
//
//	SELECT id
//	FROM "profile"
//	WHERE slug = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileIdBySlug(ctx context.Context, arg GetProfileIdBySlugParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getProfileIdBySlug, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getProfileLinksByProfileId = `-- name: GetProfileLinksByProfileId :many
SELECT id, profile_id, kind, "order", is_managed, is_verified, is_hidden, remote_id, public_id, uri, title, auth_provider, auth_access_token_scope, auth_access_token, auth_access_token_expires_at, auth_refresh_token, auth_refresh_token_expires_at, properties, created_at, updated_at, deleted_at
FROM "profile_link"
WHERE profile_id = $1
  AND is_hidden = FALSE
  AND deleted_at IS NULL
ORDER BY "order"
`

type GetProfileLinksByProfileIdParams struct {
	ProfileId string `db:"profile_id" json:"profile_id"`
}

// GetProfileLinksByProfileId
//
//	SELECT id, profile_id, kind, "order", is_managed, is_verified, is_hidden, remote_id, public_id, uri, title, auth_provider, auth_access_token_scope, auth_access_token, auth_access_token_expires_at, auth_refresh_token, auth_refresh_token_expires_at, properties, created_at, updated_at, deleted_at
//	FROM "profile_link"
//	WHERE profile_id = $1
//	  AND is_hidden = FALSE
//	  AND deleted_at IS NULL
//	ORDER BY "order"
func (q *Queries) GetProfileLinksByProfileId(ctx context.Context, arg GetProfileLinksByProfileIdParams) ([]*ProfileLink, error) {
	rows, err := q.db.QueryContext(ctx, getProfileLinksByProfileId, arg.ProfileId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProfileLink{}
	for rows.Next() {
		var i ProfileLink
		if err := rows.Scan(
			&i.Id,
			&i.ProfileId,
			&i.Kind,
			&i.Order,
			&i.IsManaged,
			&i.IsVerified,
			&i.IsHidden,
			&i.RemoteId,
			&i.PublicId,
			&i.Uri,
			&i.Title,
			&i.AuthProvider,
			&i.AuthAccessTokenScope,
			&i.AuthAccessToken,
			&i.AuthAccessTokenExpiresAt,
			&i.AuthRefreshToken,
			&i.AuthRefreshTokenExpiresAt,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileLinksForKind = `-- name: GetProfileLinksForKind :many
SELECT pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.is_hidden, pl.remote_id, pl.public_id, pl.uri, pl.title, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
  AND p.deleted_at IS NULL
WHERE pl.kind = $1
  AND pl.deleted_at IS NULL
ORDER BY pl."order"
`

type GetProfileLinksForKindParams struct {
	Kind string `db:"kind" json:"kind"`
}

// GetProfileLinksForKind
//
//	SELECT pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.is_hidden, pl.remote_id, pl.public_id, pl.uri, pl.title, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	  AND p.deleted_at IS NULL
//	WHERE pl.kind = $1
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl."order"
func (q *Queries) GetProfileLinksForKind(ctx context.Context, arg GetProfileLinksForKindParams) ([]*ProfileLink, error) {
	rows, err := q.db.QueryContext(ctx, getProfileLinksForKind, arg.Kind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProfileLink{}
	for rows.Next() {
		var i ProfileLink
		if err := rows.Scan(
			&i.Id,
			&i.ProfileId,
			&i.Kind,
			&i.Order,
			&i.IsManaged,
			&i.IsVerified,
			&i.IsHidden,
			&i.RemoteId,
			&i.PublicId,
			&i.Uri,
			&i.Title,
			&i.AuthProvider,
			&i.AuthAccessTokenScope,
			&i.AuthAccessToken,
			&i.AuthAccessTokenExpiresAt,
			&i.AuthRefreshToken,
			&i.AuthRefreshTokenExpiresAt,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilePageByProfileIdAndSlug = `-- name: GetProfilePageByProfileIdAndSlug :one
SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content
FROM "profile_page" pp
  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
  AND ppt.locale_code = $1
WHERE pp.profile_id = $2 AND pp.slug = $3 AND pp.deleted_at IS NULL
ORDER BY pp."order"
`

type GetProfilePageByProfileIdAndSlugParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileId  string `db:"profile_id" json:"profile_id"`
	PageSlug   string `db:"page_slug" json:"page_slug"`
}

type GetProfilePageByProfileIdAndSlugRow struct {
	Id              string         `db:"id" json:"id"`
	ProfileId       string         `db:"profile_id" json:"profile_id"`
	Slug            string         `db:"slug" json:"slug"`
	Order           int32          `db:"order" json:"order"`
	CoverPictureUri sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
	CreatedAt       time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt       sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	ProfilePageId   string         `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	Content         string         `db:"content" json:"content"`
}

// GetProfilePageByProfileIdAndSlug
//
//	SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content
//	FROM "profile_page" pp
//	  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
//	  AND ppt.locale_code = $1
//	WHERE pp.profile_id = $2 AND pp.slug = $3 AND pp.deleted_at IS NULL
//	ORDER BY pp."order"
func (q *Queries) GetProfilePageByProfileIdAndSlug(ctx context.Context, arg GetProfilePageByProfileIdAndSlugParams) (*GetProfilePageByProfileIdAndSlugRow, error) {
	row := q.db.QueryRowContext(ctx, getProfilePageByProfileIdAndSlug, arg.LocaleCode, arg.ProfileId, arg.PageSlug)
	var i GetProfilePageByProfileIdAndSlugRow
	err := row.Scan(
		&i.Id,
		&i.ProfileId,
		&i.Slug,
		&i.Order,
		&i.CoverPictureUri,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProfilePageId,
		&i.LocaleCode,
		&i.Title,
		&i.Summary,
		&i.Content,
	)
	return &i, err
}

const getProfilePagesByProfileId = `-- name: GetProfilePagesByProfileId :many
SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content
FROM "profile_page" pp
  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
  AND ppt.locale_code = $1
WHERE pp.profile_id = $2
  AND pp.deleted_at IS NULL
ORDER BY pp."order"
`

type GetProfilePagesByProfileIdParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileId  string `db:"profile_id" json:"profile_id"`
}

type GetProfilePagesByProfileIdRow struct {
	Id              string         `db:"id" json:"id"`
	ProfileId       string         `db:"profile_id" json:"profile_id"`
	Slug            string         `db:"slug" json:"slug"`
	Order           int32          `db:"order" json:"order"`
	CoverPictureUri sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
	CreatedAt       time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt       sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	ProfilePageId   string         `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	Content         string         `db:"content" json:"content"`
}

// GetProfilePagesByProfileId
//
//	SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content
//	FROM "profile_page" pp
//	  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
//	  AND ppt.locale_code = $1
//	WHERE pp.profile_id = $2
//	  AND pp.deleted_at IS NULL
//	ORDER BY pp."order"
func (q *Queries) GetProfilePagesByProfileId(ctx context.Context, arg GetProfilePagesByProfileIdParams) ([]*GetProfilePagesByProfileIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilePagesByProfileId, arg.LocaleCode, arg.ProfileId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProfilePagesByProfileIdRow{}
	for rows.Next() {
		var i GetProfilePagesByProfileIdRow
		if err := rows.Scan(
			&i.Id,
			&i.ProfileId,
			&i.Slug,
			&i.Order,
			&i.CoverPictureUri,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProfilePageId,
			&i.LocaleCode,
			&i.Title,
			&i.Summary,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfileMemberships = `-- name: ListProfileMemberships :many
SELECT
  pm.id, pm.profile_id, pm.member_profile_id, pm.kind, pm.properties, pm.started_at, pm.finished_at, pm.created_at, pm.updated_at, pm.deleted_at,
  p1.id, p1.slug, p1.kind, p1.custom_domain, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at,
  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties,
  p2.id, p2.slug, p2.kind, p2.custom_domain, p2.profile_picture_uri, p2.pronouns, p2.properties, p2.created_at, p2.updated_at, p2.deleted_at,
  p2t.profile_id, p2t.locale_code, p2t.title, p2t.description, p2t.properties
FROM
	"profile_membership" pm
  INNER JOIN "profile" p1 ON p1.id = pm.profile_id
    AND ($1::TEXT IS NULL OR p1.kind = ANY(string_to_array($1::TEXT, ',')))
    AND p1.deleted_at IS NULL
  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
	  AND p1t.locale_code = $2
  INNER JOIN "profile" p2 ON p2.id = pm.member_profile_id
    AND ($3::TEXT IS NULL OR p2.kind = ANY(string_to_array($3::TEXT, ',')))
    AND p2.deleted_at IS NULL
  INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
	  AND p2t.locale_code = $2
WHERE pm.deleted_at IS NULL
    AND ($4::TEXT IS NULL OR pm.profile_id = $4::TEXT)
    AND ($5::TEXT IS NULL OR pm.member_profile_id = $5::TEXT)
`

type ListProfileMembershipsParams struct {
	FilterProfileKind       sql.NullString `db:"filter_profile_kind" json:"filter_profile_kind"`
	LocaleCode              string         `db:"locale_code" json:"locale_code"`
	FilterMemberProfileKind sql.NullString `db:"filter_member_profile_kind" json:"filter_member_profile_kind"`
	FilterProfileId         sql.NullString `db:"filter_profile_id" json:"filter_profile_id"`
	FilterMemberProfileId   sql.NullString `db:"filter_member_profile_id" json:"filter_member_profile_id"`
}

type ListProfileMembershipsRow struct {
	ProfileMembership ProfileMembership `db:"profile_membership" json:"profile_membership"`
	Profile           Profile           `db:"profile" json:"profile"`
	ProfileTx         ProfileTx         `db:"profile_tx" json:"profile_tx"`
	Profile_2         Profile           `db:"profile_2" json:"profile_2"`
	ProfileTx_2       ProfileTx         `db:"profile_tx_2" json:"profile_tx_2"`
}

// ListProfileMemberships
//
//	SELECT
//	  pm.id, pm.profile_id, pm.member_profile_id, pm.kind, pm.properties, pm.started_at, pm.finished_at, pm.created_at, pm.updated_at, pm.deleted_at,
//	  p1.id, p1.slug, p1.kind, p1.custom_domain, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at,
//	  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties,
//	  p2.id, p2.slug, p2.kind, p2.custom_domain, p2.profile_picture_uri, p2.pronouns, p2.properties, p2.created_at, p2.updated_at, p2.deleted_at,
//	  p2t.profile_id, p2t.locale_code, p2t.title, p2t.description, p2t.properties
//	FROM
//		"profile_membership" pm
//	  INNER JOIN "profile" p1 ON p1.id = pm.profile_id
//	    AND ($1::TEXT IS NULL OR p1.kind = ANY(string_to_array($1::TEXT, ',')))
//	    AND p1.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
//		  AND p1t.locale_code = $2
//	  INNER JOIN "profile" p2 ON p2.id = pm.member_profile_id
//	    AND ($3::TEXT IS NULL OR p2.kind = ANY(string_to_array($3::TEXT, ',')))
//	    AND p2.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//		  AND p2t.locale_code = $2
//	WHERE pm.deleted_at IS NULL
//	    AND ($4::TEXT IS NULL OR pm.profile_id = $4::TEXT)
//	    AND ($5::TEXT IS NULL OR pm.member_profile_id = $5::TEXT)
func (q *Queries) ListProfileMemberships(ctx context.Context, arg ListProfileMembershipsParams) ([]*ListProfileMembershipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfileMemberships,
		arg.FilterProfileKind,
		arg.LocaleCode,
		arg.FilterMemberProfileKind,
		arg.FilterProfileId,
		arg.FilterMemberProfileId,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfileMembershipsRow{}
	for rows.Next() {
		var i ListProfileMembershipsRow
		if err := rows.Scan(
			&i.ProfileMembership.Id,
			&i.ProfileMembership.ProfileId,
			&i.ProfileMembership.MemberProfileId,
			&i.ProfileMembership.Kind,
			&i.ProfileMembership.Properties,
			&i.ProfileMembership.StartedAt,
			&i.ProfileMembership.FinishedAt,
			&i.ProfileMembership.CreatedAt,
			&i.ProfileMembership.UpdatedAt,
			&i.ProfileMembership.DeletedAt,
			&i.Profile.Id,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.CustomDomain,
			&i.Profile.ProfilePictureUri,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.ProfileTx.ProfileId,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.Profile_2.Id,
			&i.Profile_2.Slug,
			&i.Profile_2.Kind,
			&i.Profile_2.CustomDomain,
			&i.Profile_2.ProfilePictureUri,
			&i.Profile_2.Pronouns,
			&i.Profile_2.Properties,
			&i.Profile_2.CreatedAt,
			&i.Profile_2.UpdatedAt,
			&i.Profile_2.DeletedAt,
			&i.ProfileTx_2.ProfileId,
			&i.ProfileTx_2.LocaleCode,
			&i.ProfileTx_2.Title,
			&i.ProfileTx_2.Description,
			&i.ProfileTx_2.Properties,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfiles = `-- name: ListProfiles :many
SELECT p.id, p.slug, p.kind, p.custom_domain, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties
FROM "profile" p
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = $1
WHERE ($2::TEXT IS NULL OR p.kind = ANY(string_to_array($2::TEXT, ',')))
  AND p.deleted_at IS NULL
`

type ListProfilesParams struct {
	LocaleCode string         `db:"locale_code" json:"locale_code"`
	FilterKind sql.NullString `db:"filter_kind" json:"filter_kind"`
}

type ListProfilesRow struct {
	Profile   Profile   `db:"profile" json:"profile"`
	ProfileTx ProfileTx `db:"profile_tx" json:"profile_tx"`
}

// ListProfiles
//
//	SELECT p.id, p.slug, p.kind, p.custom_domain, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties
//	FROM "profile" p
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = $1
//	WHERE ($2::TEXT IS NULL OR p.kind = ANY(string_to_array($2::TEXT, ',')))
//	  AND p.deleted_at IS NULL
func (q *Queries) ListProfiles(ctx context.Context, arg ListProfilesParams) ([]*ListProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfiles, arg.LocaleCode, arg.FilterKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfilesRow{}
	for rows.Next() {
		var i ListProfilesRow
		if err := rows.Scan(
			&i.Profile.Id,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.CustomDomain,
			&i.Profile.ProfilePictureUri,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.ProfileTx.ProfileId,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProfile = `-- name: RemoveProfile :execrows
UPDATE "profile"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type RemoveProfileParams struct {
	Id string `db:"id" json:"id"`
}

// RemoveProfile
//
//	UPDATE "profile"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) RemoveProfile(ctx context.Context, arg RemoveProfileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeProfile, arg.Id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfile = `-- name: UpdateProfile :execrows
UPDATE "profile"
SET slug = $1
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateProfileParams struct {
	Slug string `db:"slug" json:"slug"`
	Id   string `db:"id" json:"id"`
}

// UpdateProfile
//
//	UPDATE "profile"
//	SET slug = $1
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfile, arg.Slug, arg.Id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
