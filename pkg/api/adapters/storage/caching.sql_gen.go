// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: caching.sql

package storage

import (
	"context"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const getFromCache = `-- name: GetFromCache :one
SELECT value, updated_at
FROM "cache"
WHERE key = $1
LIMIT 1
`

type GetFromCacheParams struct {
	Key string `db:"key" json:"key"`
}

type GetFromCacheRow struct {
	Value     pqtype.NullRawMessage `db:"value" json:"value"`
	UpdatedAt time.Time             `db:"updated_at" json:"updated_at"`
}

// GetFromCache
//
//	SELECT value, updated_at
//	FROM "cache"
//	WHERE key = $1
//	LIMIT 1
func (q *Queries) GetFromCache(ctx context.Context, arg GetFromCacheParams) (*GetFromCacheRow, error) {
	row := q.db.QueryRowContext(ctx, getFromCache, arg.Key)
	var i GetFromCacheRow
	err := row.Scan(&i.Value, &i.UpdatedAt)
	return &i, err
}

const getFromCacheSince = `-- name: GetFromCacheSince :one
SELECT value, updated_at
FROM "cache"
WHERE key = $1
  AND updated_at > $2
LIMIT 1
`

type GetFromCacheSinceParams struct {
	Key   string    `db:"key" json:"key"`
	Since time.Time `db:"since" json:"since"`
}

type GetFromCacheSinceRow struct {
	Value     pqtype.NullRawMessage `db:"value" json:"value"`
	UpdatedAt time.Time             `db:"updated_at" json:"updated_at"`
}

// GetFromCacheSince
//
//	SELECT value, updated_at
//	FROM "cache"
//	WHERE key = $1
//	  AND updated_at > $2
//	LIMIT 1
func (q *Queries) GetFromCacheSince(ctx context.Context, arg GetFromCacheSinceParams) (*GetFromCacheSinceRow, error) {
	row := q.db.QueryRowContext(ctx, getFromCacheSince, arg.Key, arg.Since)
	var i GetFromCacheSinceRow
	err := row.Scan(&i.Value, &i.UpdatedAt)
	return &i, err
}

const removeAllFromCache = `-- name: RemoveAllFromCache :execrows
DELETE FROM "cache"
`

// RemoveAllFromCache
//
//	DELETE FROM "cache"
func (q *Queries) RemoveAllFromCache(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeAllFromCache)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removeExpiredFromCache = `-- name: RemoveExpiredFromCache :execrows
DELETE FROM "cache"
WHERE updated_at < $1
`

type RemoveExpiredFromCacheParams struct {
	Before time.Time `db:"before" json:"before"`
}

// RemoveExpiredFromCache
//
//	DELETE FROM "cache"
//	WHERE updated_at < $1
func (q *Queries) RemoveExpiredFromCache(ctx context.Context, arg RemoveExpiredFromCacheParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeExpiredFromCache, arg.Before)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removeFromCache = `-- name: RemoveFromCache :execrows
DELETE FROM "cache"
WHERE key = $1
`

type RemoveFromCacheParams struct {
	Key string `db:"key" json:"key"`
}

// RemoveFromCache
//
//	DELETE FROM "cache"
//	WHERE key = $1
func (q *Queries) RemoveFromCache(ctx context.Context, arg RemoveFromCacheParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeFromCache, arg.Key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setInCache = `-- name: SetInCache :execrows
INSERT INTO "cache" (key, value, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT ("key") DO UPDATE SET value = $2, updated_at = NOW()
`

type SetInCacheParams struct {
	Key   string                `db:"key" json:"key"`
	Value pqtype.NullRawMessage `db:"value" json:"value"`
}

// SetInCache
//
//	INSERT INTO "cache" (key, value, updated_at)
//	VALUES ($1, $2, NOW())
//	ON CONFLICT ("key") DO UPDATE SET value = $2, updated_at = NOW()
func (q *Queries) SetInCache(ctx context.Context, arg SetInCacheParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, setInCache, arg.Key, arg.Value)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
