// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package storage

import (
	"context"
	"database/sql"
	"errors"
	"github.com/eser/aya.is-services/pkg/api/business/users"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "user" (
    id,
    kind,
    NAME,
    email,
    phone,
    github_handle,
    github_remote_id,
    bsky_handle,
    bsky_remote_id,
    x_handle,
    x_remote_id,
    individual_profile_id
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
  ) RETURNING id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
`

// CreateUser
//
//	INSERT INTO "user" (
//	    id,
//	    kind,
//	    NAME,
//	    email,
//	    phone,
//	    github_handle,
//	    github_remote_id,
//	    bsky_handle,
//	    bsky_remote_id,
//	    x_handle,
//	    x_remote_id,
//	    individual_profile_id
//	  )
//	VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9,
//	    $10,
//	    $11,
//	    $12
//	  ) RETURNING id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
func (q *Queries) CreateUser(ctx context.Context, arg users.CreateUserParams) (*users.User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Id,
		arg.Kind,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.GithubHandle,
		arg.GithubRemoteId,
		arg.BskyHandle,
		arg.BskyRemoteId,
		arg.XHandle,
		arg.XRemoteId,
		arg.IndividualProfileId,
	)
	var i users.User
	err := row.Scan(
		&i.Id,
		&i.Kind,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.GithubHandle,
		&i.GithubRemoteId,
		&i.BskyHandle,
		&i.BskyRemoteId,
		&i.XHandle,
		&i.XRemoteId,
		&i.IndividualProfileId,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	if err != nil && errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	return &i, err
}

const deleteUser = `-- name: DeleteUser :execrows
UPDATE "user"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

// DeleteUser
//
//	UPDATE "user"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DeleteUser(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
FROM "user"
WHERE email = $1
  AND deleted_at IS NULL
LIMIT 1
`

// GetUserByEmail
//
//	SELECT id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
//	FROM "user"
//	WHERE email = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (*users.User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i users.User
	err := row.Scan(
		&i.Id,
		&i.Kind,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.GithubHandle,
		&i.GithubRemoteId,
		&i.BskyHandle,
		&i.BskyRemoteId,
		&i.XHandle,
		&i.XRemoteId,
		&i.IndividualProfileId,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	if err != nil && errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	return &i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
FROM "user"
WHERE id = $1
  AND deleted_at IS NULL
LIMIT 1
`

// GetUserById
//
//	SELECT id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
//	FROM "user"
//	WHERE id = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetUserById(ctx context.Context, id string) (*users.User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i users.User
	err := row.Scan(
		&i.Id,
		&i.Kind,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.GithubHandle,
		&i.GithubRemoteId,
		&i.BskyHandle,
		&i.BskyRemoteId,
		&i.XHandle,
		&i.XRemoteId,
		&i.IndividualProfileId,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	if err != nil && errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	return &i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
FROM "user"
WHERE deleted_at IS NULL
`

// ListUsers
//
//	SELECT id, kind, name, email, phone, github_handle, github_remote_id, bsky_handle, bsky_remote_id, x_handle, x_remote_id, individual_profile_id, created_at, updated_at, deleted_at
//	FROM "user"
//	WHERE deleted_at IS NULL
func (q *Queries) ListUsers(ctx context.Context) ([]*users.User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*users.User{}
	for rows.Next() {
		var i users.User
		if err := rows.Scan(
			&i.Id,
			&i.Kind,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.GithubHandle,
			&i.GithubRemoteId,
			&i.BskyHandle,
			&i.BskyRemoteId,
			&i.XHandle,
			&i.XRemoteId,
			&i.IndividualProfileId,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :execrows
UPDATE "user"
SET kind = $1,
  NAME = $2,
  email = $3,
  phone = $4,
  github_handle = $5,
  github_remote_id = $6,
  bsky_handle = $7,
  bsky_remote_id = $8,
  x_handle = $9,
  x_remote_id = $10,
  individual_profile_id = $11
WHERE id = $12
  AND deleted_at IS NULL
`

// UpdateUser
//
//	UPDATE "user"
//	SET kind = $1,
//	  NAME = $2,
//	  email = $3,
//	  phone = $4,
//	  github_handle = $5,
//	  github_remote_id = $6,
//	  bsky_handle = $7,
//	  bsky_remote_id = $8,
//	  x_handle = $9,
//	  x_remote_id = $10,
//	  individual_profile_id = $11
//	WHERE id = $12
//	  AND deleted_at IS NULL
func (q *Queries) UpdateUser(ctx context.Context, arg users.UpdateUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateUser,
		arg.Kind,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.GithubHandle,
		arg.GithubRemoteId,
		arg.BskyHandle,
		arg.BskyRemoteId,
		arg.XHandle,
		arg.XRemoteId,
		arg.IndividualProfileId,
		arg.Id,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
